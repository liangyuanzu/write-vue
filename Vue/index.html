<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
<script>
/*
  1.Vue响应式的原理是什么?
    实时监听数据变化, 一旦数据发生变化就更新界面
  2.Vue是如何实现时时监听数据变化的?
    通过原生JS的defineProperty方法
* */

class Observer {
  constructor (data) {
    this.observer(data)
  }
  observer(obj) {
    if(obj && typeof obj === 'object') {
      for(const key in obj) {
        this.defineReactive(obj, key, obj[key])
      }
    }
  }
  defineReactive(obj, attr, value) {
    // 如果属性的取值又是一个对象, 那么也需要给这个对象的所有属性添加get/set方法
    this.observer(value)
    /**
     * Object.defineProperty(obj, prop, descriptor)
     * 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象
     * @param {object} obj  要定义属性的对象。
     * @param  prop  要定义或修改的属性的名称或 Symbol 。
     * @param {object} descriptor  要定义或修改的属性描述符。
     *    @param {any} value  属性对应的值,可以是任意类型的值，默认为undefined
     *    @param {boolean} writable  属性的值是否可以被重写。默认为false。
     *    @param {boolean} enumerable  目标属性是否可以被枚举。默认为false。
     *    @param {boolean} configurable  目标属性是否可以被删除或是否可以再次修改特性。默认为false。
     */
    Object.defineProperty(obj, attr, {
      // 当使用了getter或setter方法，不允许使用writable和value这两个属性
      get: () => value, //当获取值的时候触发的函数
      set: (newValue) => {  //当设置值的时候触发的函数
        if(value !== newValue) {
          // 如果给属性赋值的新值又是一个对象, 那么也需要给这个对象的所有属性添加get/set方法
          this.observer(newValue)
          value = newValue
          console.log('监听到数据的变化, 需要去更新UI');
        }
      }
    })
  }
}

let obj = {
  name: {
    first: 'Jason',
    last: 'liang'
  }
}
new Observer(obj)
obj.name.first = 'newFirst'
</script>
</body>
</html>